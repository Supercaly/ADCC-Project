% !TEX root = ice2022.tex
Erlang~\cite{Cesarini,Armstrong} is a general purpose, functional, concurrent programming language originally developed by Ericsson.
The peculiarity of Erlang is that is has been developed to work with fault resiliant distributed systems (originally telephony switches), hence it natively supports high degree of concurrency, light-weight processes and  failure mechanisms. Erlang concurrency model is based on the Actor model~\cite{actor}: an actor is a light-weight process endowed with a mailbox and univocally identified by a process ID (PID). A mailbox is a message-queue, to which messages are sent in a non-blocking fashion. An actor consumes messages from its mailbox  via pattern-matching obeying to a FIFO policy. 
%
%
PIDs are the only way to know actors and to communicate with them: to send a message to an actor one needs to know its PID. Also, PIDs can be send around with messages, making the discovery of actors very simple. Lastly, actors can spawn new actors at runtime. For example in the following code
\input{example1}
at line $2$ a new actor is dynamically created via the $spawn/1$ function. In Erlang a function $f$ with cardinality $n$ is indicated as $f/n$. The spawn function takes as parameter the code (function) that the new actor has to execute and
 and return the PID of the new actor. We can see that the returned PID, stored in the Pid variable, is used to send a message to the newly created actor (line $3$). To send a message to an actor, it is sufficient to know the PID of the receiver and use the $!$ operator followed by the message. In the example, the actor sends a tuple (in Erlang tuples are surrounded by curly brackets) of two elements: the \textit{atom} ping, and its PID which is obtained by the function $self()$. According to the Erlang documentation, an atom is a literal, a constant with name. Atoms are used to differentiate message content. Indeed, the actor executing the function $F$ awaits for a massage containing a tuple of two elements whose first one is the exact atom \atom{ping}, while the second element is bound to the variable P. This is how pattern-matching is done in Erlang. For example, if a message different from  $\{ping,\_\}$ arrives to the new actor, this will be no read as it does not match the pattern. At line $4$ the actor awaits for the pong message. Again, if no messages matches the patter, the actor will be blocked until a message satisfying the pattern arrives.
 
 The peculiarity of Erlang is that it does not matter whether the two actor of the example, are executed on the same machine, on two different machines in the same network, or on two different machines on two different networks. Also, Erlang comes with an ecosystem of libraries, called OTP (Open Telecom Platform), which makes it very scalable. We can list behaviours (gen_server, state machines, and the likes), rpc calls, monitors and links, ets/dets tables and the Mnesia db. This last one is of particular interest, since it is a distributed DMBS which automatically supports failures, replicas and distribution. Due to this feature, we have chosen to base our implementation of tuple space on top of Mnesia db.